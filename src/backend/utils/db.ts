import { PreparedQuery } from '@pgtyped/runtime';
import * as alarms from 'backend/db/alarms/alarms.queries';
import * as carbEntries from 'backend/db/carbEntries/carbEntries.queries';
import * as cronjobsJournal from 'backend/db/cronjobsJournal/cronjobsJournal.queries';
import * as insulinEntries from 'backend/db/insulinEntries/insulinEntries.queries';
import * as meterEntries from 'backend/db/meterEntries/meterEntries.queries';
import * as profiles from 'backend/db/profiles/profiles.queries';
import { queries } from 'backend/db/queries';
import * as sensorEntries from 'backend/db/sensorEntries/sensorEntries.queries';
import _ from 'lodash';
import { Client, Pool, types } from 'pg';
import { z } from 'zod';

/**
 * All DB modules need to be listed here to become accessible via the DB wrapper.
 */
const dbModules = {
  sensorEntries,
  carbEntries,
  insulinEntries,
  meterEntries,
  alarms,
  profiles,
  cronjobsJournal,
};

/**
 * @see https://pgtyped.dev/docs/typing
 */
types.setTypeParser(types.builtins.NUMERIC, value => parseFloat(value));
types.setTypeParser(types.builtins.TIMESTAMPTZ, value => new Date(value).toISOString());

export type DbClient = ReturnType<typeof createDbClient>;

/**
 * Creates a Postgres wrapper for talking to the database.
 */
export function createDbClient(connectionString: string) {
  const pool = new Pool({ connectionString });
  return {
    // @ts-ignore THIS WILL GET REMOVED SOON:
    ...wrapQueries(dbModules, pool),
    ...queries(pool),
    async query(query: string) {
      return await pool.query(query);
    },
  };
}

/**
 * Updates the DB modules generated by pgtyped to not require manually passing in a DB connection.
 */
function wrapQueries<
  T extends Record<
    string,
    Record<string, { run: (params: any, client: Client) => Promise<unknown> }>
  >,
>(db: T, pool: Pool) {
  return _.mapValues(db, methods =>
    _.mapValues(methods, (method: any) => (args: any) => performQuery(method, args, pool)),
  ) as unknown as {
    [K1 in keyof T]: {
      [K2 in keyof T[K1]]: (
        params: Parameters<T[K1][K2]['run']>[0],
      ) => ReturnType<T[K1][K2]['run']>;
    };
  };
}

/**
 * Performs the actual query against the DB. Also converts rows from snake_case to camelCase.
 */
const performQuery = async (
  query: { run: (args: unknown, client: Pool) => Promise<Record<string, unknown>[]> },
  args: unknown,
  pool: Pool,
) => {
  const res = await query.run(args, pool);
  return res.map(row => _.mapKeys(row, (_val, key) => _.camelCase(key)));
};

export type GenParams<T> = T extends PreparedQuery<infer P, any> ? P : void;

export const runQueryAndValidateResult = async <
  One extends boolean,
  Schema extends z.ZodTypeAny,
  Params,
>(
  pool: Pool,
  one: One,
  schema: Schema,
  method: PreparedQuery<Params, OptionalToNull<Schema>>,
  params?: Params,
): Promise<One extends true ? z.infer<Schema> : z.infer<Schema>[]> => {
  const raw = await method.run(params as Params, pool);
  const mapped = raw.map(row => _.mapKeys(row as object, (_val, key) => _.camelCase(key)));
  if (one) {
    if (mapped.length !== 1)
      throw new Error(`Expected exactly one result row but got ${mapped.length} instead`);
    return schema.parse(mapped[0]);
  } else {
    return z.array(schema).parse(mapped);
  }
};

/**
 * Our convention is to define optional model properties as:
 *
 *     z.object({
 *       profileName: z.optional(z.string()),
 *     });
 *
 * But also our optional properties are NULL-able in Postgres.
 *
 * This type papers over that difference (which we also account for runtime), and maps to:
 *
 *     {
 *       profileName: string | null;
 *     }
 */
type OptionalToNull<T> = T extends z.ZodObject<infer U>
  ? {
      [P in keyof U]: U[P] extends z.ZodOptional<infer I> ? z.infer<I> | null : z.infer<U[P]>;
    }
  : never;

export const bindQueryShorthands = (pool: Pool) => {
  const one = async <Schema extends z.ZodTypeAny, Params extends object | void>(
    schema: Schema,
    method: PreparedQuery<Params, OptionalToNull<Schema>>,
    params?: Params extends object ? Params : undefined,
  ): Promise<z.infer<Schema>> => {
    return runQueryAndValidateResult(pool, true, schema, method, params as Params);
  };

  const many = async <Schema extends z.ZodTypeAny, Params extends object | void>(
    schema: Schema,
    method: PreparedQuery<Params, OptionalToNull<Schema>>,
    params?: Params extends object ? Params : undefined,
  ): Promise<z.infer<Schema>[]> => {
    return runQueryAndValidateResult(pool, false, schema, method, params as Params);
  };

  return {
    one,
    many,
  };
};
