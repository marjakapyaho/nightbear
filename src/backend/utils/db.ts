import * as alarms from 'backend/db/alarms/alarms.queries';
import * as carbEntries from 'backend/db/carbEntries/carbEntries.queries';
import * as cronjobsJournal from 'backend/db/cronjobsJournal/cronjobsJournal.queries';
import * as insulinEntries from 'backend/db/insulinEntries/insulinEntries.queries';
import * as meterEntries from 'backend/db/meterEntries/meterEntries.queries';
import * as profiles from 'backend/db/profiles/profiles.queries';
import * as sensorEntries from 'backend/db/sensorEntries/sensorEntries.queries';
import _ from 'lodash';
import { Client, Pool, types } from 'pg';

/**
 * All DB modules need to be listed here to become accessible via the DB wrapper.
 */
const dbModules = {
  sensorEntries,
  carbEntries,
  insulinEntries,
  meterEntries,
  alarms,
  profiles,
  cronjobsJournal,
};

/**
 * @see https://pgtyped.dev/docs/typing
 */
types.setTypeParser(types.builtins.NUMERIC, value => parseFloat(value));
types.setTypeParser(types.builtins.TIMESTAMPTZ, value => new Date(value).toISOString());

export type DbClient = ReturnType<typeof createDbClient>;

/**
 * Creates a Postgres wrapper for talking to the database.
 */
export function createDbClient(connectionString: string) {
  const pool = new Pool({ connectionString })
  return {
    ...wrapQueries(dbModules, pool),
    async query(query: string) {
      return await pool.query(query)
    }
  };
}

/**
 * Updates the DB modules generated by pgtyped to not require manually passing in a DB connection.
 */
function wrapQueries<
  T extends Record<string, Record<string, { run: (params: any, client: Client) => Promise<unknown> }>>,
>(db: T, pool: Pool) {
  return _.mapValues(db, methods =>
    _.mapValues(methods, (method: any) => (args: any) => performQuery(method, args, pool)),
  ) as unknown as {
    [K1 in keyof T]: {
      [K2 in keyof T[K1]]: (params: Parameters<T[K1][K2]['run']>[0]) => ReturnType<T[K1][K2]['run']>;
    };
  };
}

/**
 * Performs the actual query against the DB. Also converts rows from snake_case to camelCase.
 */
async function performQuery(
  query: { run: (args: unknown, client: Pool) => Promise<Record<string, unknown>[]> },
  args: unknown,
  pool: Pool,
) {
  const res = await query.run(args, pool);
  return res.map(row => _.mapKeys(row, (_val, key) => _.camelCase(key)));
}
