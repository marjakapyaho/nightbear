"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindQueryShorthands = exports.runQueryAndValidateResult = exports.createDbClient = void 0;
const alarms = __importStar(require("../db/alarms/alarms.queries"));
const carbEntries = __importStar(require("../db/carbEntries/carbEntries.queries"));
const cronjobsJournal = __importStar(require("../db/cronjobsJournal/cronjobsJournal.queries"));
const insulinEntries = __importStar(require("../db/insulinEntries/insulinEntries.queries"));
const meterEntries = __importStar(require("../db/meterEntries/meterEntries.queries"));
const profiles = __importStar(require("../db/profiles/profiles.queries"));
const queries_1 = require("../db/queries");
const sensorEntries = __importStar(require("../db/sensorEntries/sensorEntries.queries"));
const pg_1 = require("pg");
const zod_1 = require("zod");
const lodash_1 = require("lodash");
/**
 * All DB modules need to be listed here to become accessible via the DB wrapper.
 */
const dbModules = {
    sensorEntries,
    carbEntries,
    insulinEntries,
    meterEntries,
    alarms,
    profiles,
    cronjobsJournal,
};
/**
 * @see https://pgtyped.dev/docs/typing
 */
pg_1.types.setTypeParser(pg_1.types.builtins.NUMERIC, value => parseFloat(value));
pg_1.types.setTypeParser(pg_1.types.builtins.TIMESTAMPTZ, value => new Date(value).toISOString());
/**
 * Creates a Postgres wrapper for talking to the database.
 */
function createDbClient(connectionString) {
    const pool = new pg_1.Pool({ connectionString });
    return {
        // @ts-ignore THIS WILL GET REMOVED SOON:
        ...wrapQueries(dbModules, pool),
        ...(0, queries_1.queries)(pool),
        async query(query) {
            return await pool.query(query);
        },
    };
}
exports.createDbClient = createDbClient;
/**
 * Updates the DB modules generated by pgtyped to not require manually passing in a DB connection.
 */
function wrapQueries(db, pool) {
    return (0, lodash_1.mapValues)(db, methods => (0, lodash_1.mapValues)(methods, (method) => (args) => performQuery(method, args, pool)));
}
/**
 * Performs the actual query against the DB. Also converts rows from snake_case to camelCase.
 */
const performQuery = async (query, args, pool) => {
    const res = await query.run(args, pool);
    return res.map(row => (0, lodash_1.mapKeys)(row, (_val, key) => (0, lodash_1.camelCase)(key)));
};
const runQueryAndValidateResult = async (pool, one, none, schema, method, params) => {
    const raw = await method.run((params ?? {}), pool);
    const mapped = raw.map(row => (0, lodash_1.mapKeys)(row, (_val, key) => (0, lodash_1.camelCase)(key)));
    if (one && none) {
        if (mapped.length === 0) {
            // TODO: fix this
            // @ts-ignore
            return undefined;
        }
        else if (mapped.length !== 1) {
            throw new Error(`Expected exactly one result or no results but got ${mapped.length} instead`);
        }
        return schema.parse(mapped[0]);
    }
    if (one) {
        if (mapped.length !== 1) {
            throw new Error(`Expected exactly one result row but got ${mapped.length} instead`);
        }
        return schema.parse(mapped[0]);
    }
    else {
        return zod_1.z.array(schema).parse(mapped);
    }
};
exports.runQueryAndValidateResult = runQueryAndValidateResult;
const bindQueryShorthands = (pool) => {
    const one = async (schema, method, params) => {
        return (0, exports.runQueryAndValidateResult)(pool, true, false, schema, method, params);
    };
    const oneOrNone = async (schema, method, params) => {
        return (0, exports.runQueryAndValidateResult)(pool, true, true, schema, method, params);
    };
    const many = async (schema, method, params) => {
        return (0, exports.runQueryAndValidateResult)(pool, false, false, schema, method, params);
    };
    return {
        one,
        oneOrNone,
        many,
    };
};
exports.bindQueryShorthands = bindQueryShorthands;
//# sourceMappingURL=db.js.map